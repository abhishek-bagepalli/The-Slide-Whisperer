import fitz  # PyMuPDF
import docx
import os
from PIL import Image
import io
from pptx import Presentation
from pptx.util import Inches, Pt
from openai import OpenAI
from dotenv import load_dotenv
import os
import json
from multimodal_rag import return_best_image


def extract_text_from_pdf(file_path):
    doc = fitz.open(file_path)
    text = ""
    for page in doc:
        text += page.get_text()
    doc.close()
    return text

def extract_images_from_pdf(file_path, output_folder="extracted_images", min_width=100, min_height=100):
    os.makedirs(output_folder, exist_ok=True)
    doc = fitz.open(file_path)
    image_paths = []

    for page_index in range(len(doc)):
        for img_index, img in enumerate(doc.get_page_images(page_index)):
            xref = img[0]
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]
            image_ext = base_image["ext"]

            # Load image in memory and check size
            image = Image.open(io.BytesIO(image_bytes))
            width, height = image.size

            if width < min_width or height < min_height:
                continue  # Skip too-small images

            # Save image if it passes size check
            image_path = os.path.join(output_folder, f"page{page_index+1}_img{img_index+1}.{image_ext}")
            with open(image_path, "wb") as f:
                f.write(image_bytes)
            image_paths.append(image_path)

    return image_paths

def extract_text_from_docx(file_path):
    doc = docx.Document(file_path)
    text = []
    for para in doc.paragraphs:
        if para.text.strip():
            text.append(para.text.strip())
    return "\n".join(text)

def extract_images_from_docx(file_path, output_folder="extracted_images"):
    from docx.image.image import Image as DocxImage
    os.makedirs(output_folder, exist_ok=True)
    doc = docx.Document(file_path)
    image_paths = []
    for i, rel in doc.part._rels.items():
        if "image" in rel.target_ref:
            image_data = rel.target_part.blob
            ext = rel.target_ref.split('.')[-1]
            image_path = os.path.join(output_folder, f"image_{len(image_paths)+1}.{ext}")
            with open(image_path, "wb") as f:
                f.write(image_data)
            image_paths.append(image_path)
    return image_paths

def extract_text_and_images(file_path,save_text_to_file=True):
    if file_path.endswith('.pdf'):
        text = extract_text_from_pdf(file_path)
        images = extract_images_from_pdf(file_path)
        tables = []
    elif file_path.endswith('.docx'):
        text = extract_text_from_docx(file_path)
        images = extract_images_from_docx(file_path)
        tables = extract_tables_from_docx(file_path)
    else:
        raise ValueError("Unsupported file type. Only .pdf and .docx are supported.")
    
    if save_text_to_file:
        base_name = os.path.splitext(os.path.basename(file_path))[0]
        text_output_path = f"{base_name}_extracted.txt"
        with open(text_output_path, "w", encoding="utf-8") as f:
            f.write(text)
        print(f"âœ… Extracted text saved to {text_output_path}")

    return text, images, tables

def get_image_paths_from_folder(folder_path):
    valid_exts = ('.png', '.jpg', '.jpeg', '.bmp')
    image_paths = [
        os.path.join(folder_path, f)
        for f in os.listdir(folder_path)
        if f.lower().endswith(valid_exts)
    ]
    # Optional: Sort by filename (e.g., page1_img1.png < page2_img1.png)
    return sorted(image_paths)

def extract_tables_from_docx(file_path):
    doc = docx.Document(file_path)
    tables_data = []

    for table in doc.tables:
        table_content = []
        for row in table.rows:
            row_content = [cell.text.strip() for cell in row.cells]
            table_content.append(row_content)
        tables_data.append(table_content)

    return tables_data

def summarize_tables(tables):
    table_summaries = []
    for idx, table in enumerate(tables):
        if not table:
            continue
        headers = table[0]
        table_summaries.append(f"Table {idx+1}: {len(table)-1} rows, {len(headers)} columns. Headers: {headers}")
    return "\n".join(table_summaries)

def create_presentation_from_slide_plan(title_text, slide_plan, tables, output_path="output.pptx"):
    prs = Presentation()

    # --- Title Slide ---
    title_slide_layout = prs.slide_layouts[0]  # Title slide layout
    slide = prs.slides.add_slide(title_slide_layout)
    title = slide.shapes.title
    subtitle = slide.placeholders[1]
    title.text = title_text
    subtitle.text = "Generated by SmartSlideGen âœ¨"

    # --- Content Slides ---
    for idx, slide_info in enumerate(slide_plan):
        blank_slide_layout = prs.slide_layouts[6]  # Blank layout
        slide = prs.slides.add_slide(blank_slide_layout)

        # --- Insert Title ---
        title_box = slide.shapes.add_textbox(Inches(0.5), Inches(0.2), Inches(9), Inches(1))
        title_frame = title_box.text_frame
        title_frame.text = slide_info.get("title", f"Slide {idx+1}")

        # --- Insert Text ---
        text_content = slide_info.get("text", "")
        text_layout = slide_info.get("text_box", {}).get("layout", "center")

        # Default text box position and size
        text_width = Inches(6)
        text_height = Inches(2.5)
        
        if text_layout == "left":
            text_x, text_y = Inches(0.5), Inches(2)
        elif text_layout == "right":
            text_x, text_y = Inches(5.5), Inches(2)
        elif text_layout == "top":
            text_x, text_y = Inches(1), Inches(1)
        elif text_layout == "bottom":
            text_x, text_y = Inches(1), Inches(4)
        elif text_layout == "center":
            text_x, text_y = Inches(2), Inches(2.5)
        else:
            text_x, text_y = Inches(2), Inches(2.5)  # fallback center

        text_box = slide.shapes.add_textbox(text_x, text_y, text_width, text_height)
        text_frame = text_box.text_frame
        text_frame.word_wrap = True
        text_frame.text = text_content
        text_frame.fit_text()  # ðŸ§  Auto-fit text to avoid overflow

        # --- Insert Visual Element if any ---
        visual_element = slide_info.get("visual_element", "TextOnly")
        
        if visual_element == "Table":
            table_idx = slide_info.get("table_index", None)
            visual_layout = slide_info.get("visual_box", {}).get("layout", "bottom")

            if table_idx is not None and table_idx < len(tables):
                table_data = tables[table_idx]
                if table_data:
                    # Set table size
                    rows = len(table_data)
                    cols = len(table_data[0])

                    table_width = Inches(8)
                    table_height = Inches(3)

                    if visual_layout == "bottom":
                        table_x, table_y = Inches(1), Inches(4)
                    elif visual_layout == "top":
                        table_x, table_y = Inches(1), Inches(1.5)
                    elif visual_layout == "left":
                        table_x, table_y = Inches(0.5), Inches(2)
                    elif visual_layout == "right":
                        table_x, table_y = Inches(5.5), Inches(2)
                    else:
                        table_x, table_y = Inches(1), Inches(4)

                    table_shape = slide.shapes.add_table(rows, cols, table_x, table_y, table_width, table_height).table

                    # Fill in table content
                    for r in range(rows):
                        for c in range(cols):
                            cell = table_shape.cell(r, c)
                            cell.text = str(table_data[r][c])

                            # Optional: set smaller font
                            for paragraph in cell.text_frame.paragraphs:
                                for run in paragraph.runs:
                                    run.font.size = Pt(10)

        elif visual_element == "Image":

            image_caption = slide_info.get("image_caption", "Image")
            # Use the image_caption to find the best image from the folder
            image_folder = "extracted_images"
            best_image_path, score = return_best_image(image_caption, image_folder=image_folder)

            best_image_path = 'extracted_images/' + best_image_path

            visual_layout = slide_info.get("visual_box", {}).get("layout", "right")

            if best_image_path and os.path.exists(best_image_path):
                from PIL import Image as PILImage

                # Load the image and get dimensions
                img = PILImage.open(best_image_path)
                img_width, img_height = img.size

                # Max dimensions you want (inches)
                max_width = 4
                max_height = 3

                # Scale proportionally
                scale_w = max_width * 96 / img_width  # 96 DPI
                scale_h = max_height * 96 / img_height
                scale = min(scale_w, scale_h, 1.0)

                final_width_in = (img_width * scale) / 96
                final_height_in = (img_height * scale) / 96

                # Placement based on layout
                if visual_layout == "left":
                    img_x, img_y = Inches(0.5), Inches(2)
                elif visual_layout == "right":
                    img_x, img_y = Inches(5.5), Inches(2)
                elif visual_layout == "top":
                    img_x, img_y = Inches(2), Inches(1)
                elif visual_layout == "bottom":
                    img_x, img_y = Inches(2), Inches(4.5)
                else:  # center fallback
                    img_x, img_y = Inches(3), Inches(2.5)

                # Insert image
                slide.shapes.add_picture(best_image_path, img_x, img_y, width=Inches(final_width_in), height=Inches(final_height_in))
            else:
                print(f"âš ï¸ Image path not found: {best_image_path}")

        elif visual_element == "SmartArt":
            smart_art_type = slide_info.get("smart_art_type", "Process")
            visual_layout = slide_info.get("visual_box", {}).get("layout", "center")

            if smart_art_type == "Process":
                # Simple horizontal flow
                shapes = []
                start_x = Inches(1)
                start_y = Inches(3)
                box_width = Inches(2)
                box_height = Inches(1)
                gap = Inches(0.5)

                for i in range(3):  # create 3 steps
                    box = slide.shapes.add_shape(
                        1,  # Rectangle (auto shape ID for Rectangle)
                        start_x + i*(box_width+gap),
                        start_y,
                        box_width,
                        box_height
                    )
                    box.text = f"Step {i+1}"
                    shapes.append(box)

                # Optional: Add arrows later
            elif smart_art_type == "Hierarchy":
                # Simulate 1 top + 2 bottom boxes
                top_box = slide.shapes.add_shape(1, Inches(4), Inches(2), Inches(2), Inches(1))
                top_box.text = "Leader"

                child1 = slide.shapes.add_shape(1, Inches(2), Inches(4), Inches(2), Inches(1))
                child1.text = "Team A"

                child2 = slide.shapes.add_shape(1, Inches(6), Inches(4), Inches(2), Inches(1))
                child2.text = "Team B"

                # Optional: Add connectors manually

    # --- Save Presentation ---
    prs.save(output_path)
    print(f"âœ… Presentation saved to {output_path}")


if __name__ == "__main__":

    load_dotenv()
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

    client = OpenAI()

    file_path = "docs/loreal.docx"  # Change this to your input file

    if os.path.exists(file_path):

        text, images, tables = extract_text_and_images(file_path)
        
        print(f"âœ… {len(images)} Images Extracted")
        print(f"âœ… {len(tables)} Tables Extracted")


    else:
        print("File not found.")    

    # Get tables summary
    tables_summary = summarize_tables(tables)

    print("ðŸ“Š Tables Summary: ",tables_summary)

    # Prepare the prompt for LLM
    prompt = f"""
    You are an expert presentation designer tasked with generating an initial slide plan for a PowerPoint deck.

    Based on the extracted content below (text, tables, images), create a clean structure for a slide deck.

    For each slide, you must decide:
    - Slide title
    - Main text content (summarized, simple, not too long)
    - Visual element decision:
        - TextOnly
        - Image (if an image would help explain the content clearly)
        - Table (only if relevant table is available)
        - SmartArt (only if content suggests a process, hierarchy, or cycle)
    - Layout decision:
        - Text box position: left, right, center, top, bottom
        - Visual element (if any) position: left, right, center, top, bottom
    - Visual sizing (optional advanced): max width and height (in inches)

    If SmartArt is needed, suggest a type:
    - "Process", "Hierarchy", "Cycle", "Relationship", etc.

    If Image is used, instead of selecting an image from the list, describe what the image should show.
    This will later be used to automatically select the most relevant image from a local collection.

    Output Format:
    Return a JSON list.
    Each slide must be an object with these fields:

    {{
        "title": "Slide Title",
        "text": "Summarized main text (not bullets)",
        "visual_element": "TextOnly" | "Image" | "Table" | "SmartArt",
        "smart_art_type": "..."       // only if visual_element is SmartArt
        "image_caption": "..."        // only if visual_element is Image â€” describe what the image should show
        "table_index": 0              // only if visual_element is Table
        "text_box": {{"layout": "left" | "right" | "top" | "bottom" | "center"}},
        "visual_box": {{"layout": "left" | "right" | "top" | "bottom" | "center"}}
    }}

    ---

    Extracted Text:
    {text[:10000]}

    Extracted Tables Summary:
    {tables_summary}

    ---

    Notes:
    - Keep the text concise and suitable for slide content (ideally <70 words).
    - Use an image only when it would enhance understanding.
    - If an image is needed, describe what it should depict (e.g., "a bar chart showing market share by region").
    - Always include text_box and visual_box layout fields.

    Ensure your JSON is strictly valid and parseable.
    """


    print("ðŸ“¤ Sending request to LLM...")

    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "user", "content": prompt}
        ],
        temperature=0.5,  # moderate creativity
        max_tokens=1000  # large output if needed
    )

    slide_plan_raw = response.choices[0].message.content

    try:
        slide_plan = json.loads(slide_plan_raw)
    except json.JSONDecodeError as e:
        print("âš ï¸ JSON parsing error:", e)
        slide_plan = []  # fallback empty or you can handle differently

    print("ðŸ“¥ Received response from LLM.")
    print(slide_plan)

    print(type(slide_plan))
    # writing slide_plan to a local json file for debugging
    with open("slide_plan.json", "w") as f:
        json.dump(slide_plan, f, indent=4)

    print("ðŸ“Š Creating presentation...")
    create_presentation_from_slide_plan(
    title_text="SmartSlideGen Deck",
    slide_plan=slide_plan,
    tables=tables,
    output_path="SmartSlideGen_Final.pptx"
)


